Template Filters
****************

.[caution]
Ve verzi 0.9.0 se tento filtr jmenuje stále CurlyBrackets!

Filtr Latte (dříve CurlyBrackets)
=================

Zjednodušuje zápis šablon.


| Zápis v Latte                           | PHP ekvivalent nebo význam
|------------------------------------------------------------------------------------------------
| `{$variable}`                            | `<?php echo htmlSpecialChars($variable) ?>`
| `{!$variable}`                           | `<?php echo $variable ?>`
| `{=expression}`                          | `<?php echo htmlSpecialChars(expression) ?>`
| `{!=expression}`                         | `<?php echo expression ?>`
| `{?expression}`                          | vyhodnotí PHP kód
| "`{_expression}`":[#toc-preklady]            | vypíše překlad s escapováním
| `{!_expression}`                         | vypíše překlad bez escapování
| `{*text komentáře*}`                     | komentář, bude odstraněn
| "`{plink ...}`":[#toc-znacka-plink]                 | `<?php htmlSpecialChars($presenter->link(...)) ?>`
| "`{link ...}`":[#toc-znacka-link]                   | odkaz nad komponentou (v šabloně presenteru ekvivalentní s `{plink ...}`)
| `{if ?} ... {elseif ?} ... {/if}`        | `<?php if (?): ?> ... <?php elseif (?): ?> ... <?php endif ?>`
| "`{ifCurrent}`":[#toc-znacka-ifcurrent]             | speciální případ `{if}` pro aktivní odkaz
| `{for ?} ... {/for}`                     | `<?php for (?): ?> ... <?php endfor ?>`
| "`{foreach ?} ... {/foreach}`":[#toc-foreach-cyklus]| `<?php foreach (?): ?> ... <?php endforeach ?>`
| `{while ?} ... {/while}`                 | `<?php while (?): ?> ... <?php endwhile ?>`
| `{include 'dir/file.phtml'}`             | vloží podšablonu
| "`{cache ?} ... {/cache}`":[#toc-znacky-cache-cache]      | cachovaný blok
| "`{snippet ?} ... {/snippet}`":[#toc-znacka-snippet]| control snippet
| `{attr ?}`                               | usnadňuje zápis atributů html značek
| "`{assign var => value}`":[#toc-znacka-assign-a-obracene-renderovani]        | nastaví šabloně proměnné
| `{default var => value}`        | výchozí hodnoty proměnných šablony
| "`{capture $var} ... {/capture}`":[#toc-zachytavani-vystupu-do-promenne] | zachytnutí bloku do proměnné
| `{block` \|`texy} ... {/block}`          | texy block
| "`{control ...}`":[#toc-znacka-widget]               | připraví widget
| `{contentType ?}`                        | pošle HTTP hlavičku Content-Type
| `{debugbreak}`                           | vloží breakpoint, funguje ale jen v některých IDE, např. [PhpED | http://www.nusphere.com/products/phped.htm]
| `{dump $variable}`                       | vloží Debug::dump($variable), tedy vypíše obsah proměnné pro účely ladění.


Registrace:
-----------

Filtr se registruje automaticky, není potřeba ho registrovat.

/--php
$this->template->registerFilter(new LatteFilter);
\--

.[#preklady]
Překlady
--------
//Chybí doplnit...//

.[#plink]
Značka {plink `...`}
--------
/--code html
{* vygeneruje relativní cestu na presenter např.: /neco/akce/$param1 *}
{plink NecoPresenter:akce 'parametr1'=>$param1}
{* vygeneruje absolutní cestu na presenter např.: http://example.com/neco/akce/$param1 *}
{plink //NecoPresenter:akce 'parametr1'=>$param1}
\--

.[#link]
Značka {link `...`}
--------
//Chybí doplnit...//

.[#foreach]
Foreach cyklus
--------------

Foreach cyklus se chová jako běžný `foreach` v php s několika rozšířeními.

Uvnitř cyklu je inicializovaná proměnná `$iterator`, díky které můžete zjistit některé jinak těžko zjistitelné údaje o právě probíhajícím cyklu.

Metody proměnné `$iterator`:
- `isFirst()` - prochází se cyklem poprvé?
- `isLast()` - jde o poslední průchod?
- `getCounter()` - čítač průchodů cyklem počítaný od jedničky
- `isOdd()` - jde o lichý průchod?
- `isEven()` - jde o sudý průchod?

Příklad:

/--code html
{foreach $rows as $row}
        {if $iterator->isFirst()}
        <table>
        {/if}
        <tr id="row-{$iterator->getCounter()}">
                <td>{$row->name}</td>
                <td>{$row->email}</td>
        </tr>
        {if $iterator->isLast()}
        </table>
        {/if}
{/foreach}
\--


Podpora helperů
----------------

Filtr Latte podporuje snadné volání helperů za použití této syntaxe:

/--code html
<h1>{$heading|upper}</h1>
\--

Je možno zřetězit více helperů (resp. modifikátorů):

/--code html
<h1>{$heading|lower|capitalize}</h1>
\--

Vykonají se v pořadí od levého k pravému.

Další parametry funkce helperu se zadávají za jménem helperu oddělené dvojtečkami.

/--code html
<a href="...">{$linkText|truncate:20}</a>
\--


Vlastní rozšíření filtru Latte
--------------------------------------

Třída LatteMacros (dříve CurlyBracketsMacros) definuje jednotlivé záměny ve statickém asociativním poli `$defaultMacros`. Rozšířit je lze přidáním nového prvku:

/--php
// v šabloně {podpis}
LatteMacros::$defaultMacros["podpis"] = "Já";
// v šabloně {aktualniDatum}
LatteMacros::$defaultMacros["aktualniDatum"] =
	"<?php echo date('j. n. Y') ?>";
// v šabloně {icon delete}
LatteMacros::$defaultMacros["icon"] =
	'<img src="%%.png" width="16" height="16" alt="%%">';
\--

Více o [rozšíření LatteFilter].

Přizpůsobení escapování podle lokálního typu obsahu
------------------
Velmi důležitou vlastností je přizpůsobení escapování podle lokálního typu obsahu.
Uvnitř JavaScriptu nebo uvnitř CSS se escapuje jinak, než v HTML kódu.
Díky tomu je možné zcela nativně používat PHP proměnné uvnitř JavaScriptového kódu.

Příklad:
/--php
$template->pole = array(1, 2, 3);
$template->name = "Jim Beam";
\--

/--code html
<script type="text/javascript">
<!--
var pole = {$pole};
var name = {$name}; // ALE POZOR - NESMÍ se už používat extra uvozovky
var anotherName = "{$name}";  // CHYBA, vygeneruje name = ""Jim Beam"";
// -->
</script>
\--

Vložíme-li proměnnou v šabloně do html, css nebo javascriptu, vždy se správně escapuje (`$id` je nějaký identifikátor obsahující libovolné znaky):

/--code html
<!-- #{$id} { background: blue; } -->
<p id="{$id}">Hello!</p>

<script type="text/javascript">
<!--
document.getElementById({$id}).style.backgroundColor = 'red';
// -->
</script>
\--

.[#capture]
Zachytávání výstupu do proměnné
-------------------------------

Značky `{capture}` se používají pro zachytávání výstupu do proměnné:
/--code html
{capture $var}
<ul>
        <li>Hello World</li>
</ul>
{/capture}

<p>Captured: {$var}</p>
\--

Zachytávání je přitom možné kombinovat i s modifikátory.



.[#block-texy]
Značka {block|texy}
------------------
Tam kde není vhodné použít filtr `texyElements`, například při kombinaci s filtrem `Latte`, kde by docházelo ke kolizím, můžete zkusit použít kombinace bloku a helperu.

/--php
$texy = new Texy();
// ...a jeho konfigurace

$template->registerFilter(new Nette\Templates\LatteFilter);
$template->registerHelper('texy', array($texy, 'process'));
\--

šablona:

/--code html
{block|texy}
Vítejte!
--------

Můžete používat syntax Texy!, pokud Vám vyhovuje:
- třeba **tučné** písmo nebo *kurzíva*
- a takto se dělá [odkaz | http://texy.info]

[* image.jpg *]
{/block}
\--

Označný blok s modifikátorem `texy` je pak předhozen helperu `texy`.

Pro pochopení: `{block} ... {/block}` vygeneruje něco cca takového:

/--php
<?php ob_start() ?>
Vítejte!
--------

Můžete používat syntax Texy!, pokud Vám vyhovuje:
- třeba **tučné** písmo nebo *kurzíva*
- a takto se dělá [odkaz | http://texy.info]

[* image.jpg *]
<?php echo $template->texy(ob_get_clean()) ?>
\---

A `$template->texy(...)` je volání helperu `texy`, tj. volání callbacku `array($texy, 'process')`.

Alternativní je předat do šablony proměnnou s texy obsahem a ten pak pomocí helperu převést.

šablona:
/--code html
<div>{!foo->info |texy}</div>
\--


Spolupráce s třídou Html
---------------
Filtr Latte řadu věcí zjednodušuje tak, že použití [Nette\Web\Html] dokáže zpříjemnit i například zapisování atributů. Klasickým zápisem to není úplně ono:

/--php
<a href="xxx"{if $level==0} class="top"{/if}{if $color || $background} style="{if $color}color:{$color};{/if}{if $background}background:{$background}{/if}"{/if}>
\--

Pomocí provázání filtru s třído Html lze dosáhout stejného výsledku jako v předchozím případě tímto způsobem (výsledek je ekvivalentní, tato funkce je ale zatím experimentální):


/--php
<a href="xxx" {attr class('top', $level==0) style('color', $color) style('background', $background)}>
\--

Což se vlastně přeloží jako

/--php
echo Html::el()->class('top', $level==0)->style('color', $color)->style('background', $background);
\--


.[#snippet]
Značka {snippet}
---------------
Snippety se používají při práci s Ajaxem pro označení logické oblasti na stránce, která má být jako celek v případě Ajaxového požadavku překreslena. Značky a `{snippet}` používají ve své vnitřní implementaci [SnippetHelper | api:Nette\Templates\SnippetHelper], který zjednodušuje práci s Ajaxem na nutné minimum. Celá tato problematika včetně příkladů použití je probrána na stránce [Ajax & snippety].


.[#cache]
Značky {cache} … {/cache}
--------------

/--comment
http://forum.nette.org/cs/viewtopic.php?pid=4994#p4994
\--

Pomocí značek `{cache}` a `{/cache}` lze označit části šablony, které se mají ukládat do cache. Kešování je tak možno velmi snadno doplnit i do vykreslovací části aplikace. Vnitřní implementace značky využívá [CachingHelperu | api:Nette\Templates\CachingHelper].

.[note]
Funkce je zatím experimentální.

Označené části se automaticky invalidují, když se změní šablona a to včetně i všech případných inkludovaných souborů.

Dále je podporováno vnořování značek `{cache}`. Části šablony se pak invalidují, když se invaliduje kterákoliv vnořená část.

Jako parametry je možné uvést invalidační tagy (více v [dokumentaci kešování | Nette\Caching]):
/--code html
{cache "item/$id", "comments"}
        <h1>{$title}</h1>

        {include 'spot.phtml'}
        {include 'comments.phtml'}
{/cache}
\--

Pokud šabloně předáme vazbu na model, který data vrací až "on demand" nebo-li "lazy" způsobem, tak je kešování naopak velmi efektivní a tato funkčnost přesouvá kešování tam, kde je potřeba, tedy do šablon.


.[#ifCurrent]
Značka {ifCurrent}
--------------
/--comment
http://forum.nette.org/cs/viewtopic.php?pid=5012#p5012
\--

Značka `{ifCurrent destination}` pomáhá zjistit, zda-li je cíl odkazu shodný s aktuální stránkou. Pokud odkaz směřuje na stránku, která je zrovna zobrazena, můžeme ho například jinak nastylovat a podobně.
Trik je v tom, že při generování odkazu se detekuje, jestli odkaz míří na aktuální stránku. Výsledek pak vrátí `$presenter->getCreatedRequest()->hasFlag('current')`.

/--code html
<!-- příklady použití -->
<a href="{link edit, 10}">edituj</a>
<ul class="menu">
	<li><a href="{link Default:default}">...</a></li>
	<li><a href="{link}">...</a></li>
	...
	<li {ifCurrent Default:default}class="current"{/if}><a href="{link Default:default}">...</a></li>

	<!-- rozšíření scope -->
	<li {ifCurrent Default:*}class="current"{/if}><a href="{link Default:default}">...</a></li>
</ul>
<!-- znegování -->
{ifCurrent Admin:login}{else}<a href="{link Admin:login}">Přihlašte se!</a>{/if}
\--


.[#assign]
Značka {assign} a obrácené renderování
---------
/--comment
http://forum.nette.org/cs/1131-sablona-a-layout-renderovani-v-opacnem-poradi-zruseno
http://forum.nette.org/cs/1291-curlybrackets-dedeni-sablon-extends-bug

Zavedeno v revizi [174 | http://code.google.com/p/nette/source/detail?r=174], označeno deprecated v revizi [187 | http://code.google.com/p/nette/source/detail?r=187].
\--

Při dělení obsahu webu na layout a obsah se můžeme setkat s potřebou nastavit nějaký obsah v obsahových šablonách a toto promítnout do layoutu. Pokud chceme mít například v `<title>` v layoutu stejný titulek jako v `<h1>` obsahové šablony, musíme titulek nastavit jako parametr šablony v presenteru. To stejné platí pro meta tagy, skripty a styly, jenž jsou specifické jen pro určitou stránku. Problém je zkrátka v tom, že layout se s každou stránkou také mění a přesouvat kvůli tomu části šablony do presenteru je nevyhovující.

.[note]
Funkce je zatím experimentální.

Jak věc řešit? Nejprve je třeba, aby v době renderování layoutu byla již vyrenderována obsahová šablona, odsud pramení název obrácené renderování. Po vyrenderování obsahu je možné v layoutu použít zmíněnou proměnou

/--code html
{* @layout.phtml *}
<head>
	<title>{$title}</title>
</head>
\--

...kterou nastavíme v obsahové šabloně:

/--code html
{* default.phtml *}
{assign $title 'Editace položky'}

<h1>{$title}</h1>
...
\--

Jde o experimentální funkčnost, kterou není doporučeno používat v produkčním nasazení. Musí se nejdříve aktivovat v presenteru před vykreslováním.

Presenter:
/--php
protected function beforeRender()
{
    $this->oldLayoutMode = FALSE;
}
\--


.[#widget]
Značka {control ...}
--------
Tato značka slouží pro renderování [Control | Nette\Application\Control]ů. S její pomocí nemusíte šabloně předávat do proměnných `Control`y, které hodláte zobrazit, a díky továrničkám se získávají lazy způsobem (až když jsou potřeba). Je nutné zdůraznit, jak se značka překládá do PHP. Nejjednodušší to bude ukázat na příkladu: mějme komponentu CartControl, která slouží pro zobrazení (vyrenderování) košíku u nějakého E-Shopu a chceme košík renderovat jednou jako celý košík na stránce a poté jako malý přehled (např. někde v postranní liště). Control je definován v továrničce někde v BasePresenteru. S pomocí značky `{control ...}` bychom to udělaly nějak takto:

/--html
{control cartControl}		pro celý košík na stránce
{control cartControl:small}	pro malý náhledový košík
\--
Značky se přeloží do:
/--php
$control->getWidget("cartControl")->render();
$control->getWidget("cartControl")->renderSmall();
\--

Kde metoda `getWidget()` vrací komponentu (cartControl) proměnné `$control` (BasePresenter). Nad touto komponentou volá metodu `render()`, resp. `renderSmall()` pokud je jiný způsob renderování uveden ve značce za dvojtečkou.

Lze použít i volání s parametry, které se předají render metodám, například:

/--html
{control cartControl:small $maxItems}
\--
se přeloží do:
/--php
$control->getWidget("cartControl")->renderSmall($maxItems);
\--


Dědičnost bloků
---------------

Mějme v šabloně layoutu definovány bloky `#title` a `#content` s nějakým výchozím obsahem. V nějaké šabloně pohledu zjistíme, že se nám hodí obsah těchto bodů překrýt jiným obsahem. Šablonu pohledu pak označíme značkou `{extends $layout}` a bloky `#title` a `#content` nadefinujeme s požadovaným obsahem. Proměnná `$layout` je zde cesta k souboru rodičovské šabloně. Všechny bloky se renderují v rodičovské šabloně, která je nejvýše ve stromě.

Šablona view:
/--code html
{extends $layout}

{block #title}Add New Album{/block}

{block #content}
	<h1>Add New Album</h1>

	{!$form}
{/block}
\--

Šablona layoutu:

/--code html
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<title>{block #title}Nette example{/block}</title>
</head>

<body>
	{foreach $flashes as $flash}<div class="flash {$flash->type}">{$flash->message}</div>{/foreach}

	<div id="content">
		{include #content}
	</div>

	{if isset($user)}
	<p id="logged-in">Logged in as {$user->real_name}. <a href="{link logout}">Logout</a></p>
	{/if}
</body>
</html>
\--

Takto lze vyřešit i rekurzivní volání určitého kousku kódu šablony čistě a efektivně na úrovni šablon.

Názorný příklad může být rekurzivní menu. Šabloně předáme jedinou proměnnou `$menu`, kde bude celý strom. V šabloně pomocí `{include '@menu.phtml', 'menu' => $item}` můžeme načíst jinou šablonu a v parametrech jí předat proměnné, se kterými může pracovat. Celý soubor `@menu.phtml` poté bude vypadat takto:

/--code html
<ul>
	{foreach $menu as $item}
	<li>{if is_array($item)} {include '@menu.phtml', 'menu' => $item} {else}{$item}{/if}</li>
	{/foreach}
</ul>
\--


Lze se obejít i bez pomocného souboru:

/--code html
{block #menu}
<ul>
	{foreach $menu as $item}
	<li>{if is_array($item)} {include #menu, 'menu' => $item} {else}{$item}{/if}</li>
	{/foreach}
</ul>
{/block}
\--




Filtr texyElements
==================

Dovolí používat speciální `<texy>` značky v kódu šablony.

/--code html
{* v šabloně *}
<texy>Text **tučně**, [odkaz | www.example.com] atd.</texy>
\--

Aby tento filtr fungoval, musí být inicializovaná statická proměnná `$texy` třídy `TemplateFilters`.

/--php
TemplateFilters::$texy = new Texy;
\--

*(poznámka: způsob registrace bude zřejmě změněn)*

Registrace:

/--php
$this->template->registerFilter('TemplateFilters::texyElements');
\--


Příklad registrace filtru texyElements v Presenteru
---------------
/--php
abstract class BasePresenter extends Presenter
{

    public function templatePrepareFilters($template)
    {
        parent::templatePrepareFilters($template);

        // inicializace Texy
        TemplateFilters::$texy = new Texy;
        TemplateFilters::$texy->encoding = 'utf-8';
        TemplateFilters::$texy->allowedTags = Texy::NONE;
        TemplateFilters::$texy->allowedStyles = Texy::NONE;
        TemplateFilters::$texy->setOutputMode(Texy::XHTML1_STRICT);

        $template = $this->createTemplate();

        // registrace filtru texyElements
        $template->registerFilter('TemplateFilters::texyElements');

        // registrace dalších volitelných filtrů, třeba netteLinks
        $template->registerFilter('TemplateFilters::netteLinks');
    }

}
\--

Všechny presentery, kde chceme filtr využívat, musí dědit buď `BasePresenter`, nebo nějaký z jeho potomků. Jedná se ale o velmi rannou verzi filtru `texyElements` a v produkčním nasazení se nedoporučuje jej používat. V kombinaci s filtrem `Latte` může docházet k zbytečným chybám v šablonám. Alternativou může být použití značek `block` filtru `Latte` a helperu `texy`.


Filtr removePhp
==================

Odstraní ze šablony veškerý PHP kód.

/--code html
{* v šabloně *}
Hello <?php nebezpecnaFunkce() ?> World
\--

Registrace:

/--php
$this->template->registerFilter('TemplateFilters::removePhp');
\--


Filtr netteLinks
================

Umí přeložit adresy odkazů typu `Presenter:view?arg=value` na běžnou adresu.

/--code html
{* v šabloně *}
<a href="nette:Presenter:view?arg=value">Odkaz</a>
\--

Registrace:

/--php
$this->template->registerFilter('TemplateFilters::netteLinks');
\--


Filtr relativeLinks
=============
Filtr relativeLinks přidává ke každému výskytu `src|href|action` v šabloně `$baseUri` pokud je třeba.

Použití znaku @ před značkami
=============
http://forum.nette.org/cs/2451-zavinacova-magie-v-praxi

.[see]
Viz také:
- [Nette\Templates\TemplateFilters API reference | api:Nette\Templates\TemplateFilters]
- [Nette\Templates\LatteFilter API reference | api:Nette\Templates\LatteFilter]
