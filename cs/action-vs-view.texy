Action vs. View
***************

Na počátku životního cyklu aplikace stojí požadavek na action/view (tj. [fully qualified view]). Aplikace vytvoří příslušný presenter a předá mu řízení. Ten má za úkol view "odprezentovat". V nejjednodušším případě to znamená načíst stejnojmennou šablonu a vykreslit ji.

Existují však situace, kdy se pod jedním pohledem mohou vykreslit diametrálně odlišné stránky. Příkladem je třeba pohled na zboží v e-shopu. Presenter vyhledá položku v databázi a zjistí, že:

a) v databázi je a může se zobrazit
b) v databázi je, ale má příznak "smazáno" - zobrazí se informace o nedostupnosti a nabídnou se podobné produkty
c) v databázi není - zobrazí se informace o chybějící stránce a nabídne např. vyhledávací formulář

Klíčové je si uvědomit, že tyto tři stánky existují v rámci jednoho pohledu. Presenter **nemá nic jako** "pohled na nedostupné zboží" nebo "pohled na neexistující zboží". Nelze se například na existující zboží podívat v pohledu/šabloně nedostupného zboží.

Pohled je tedy jen jeden (např. `Product:show`) a tento se rozpadá na tři pohledy. Kód by vypadal asi takto:

/--php
class ProductPresenter
{
    // action 'show' calls method 'actionShow'
    function actionShow($id)
    {
        $row = dibi::query('SELECT * FROM products WHERE id=%s', $id);
        if (!$row) {
            $this->view = 'notfound';
        } elseif ($row['deleted']) {
            $this->view = 'deleted';
        } else {
            // in this case view == 'show'
        }
    }

    function renderShow()
    { ... }

    function renderNotfound()
    { ... }

    function renderDeleted()
    { ... }
}
\--

Volání `$this->view = ...` tedy ovlivní, které metody `prepareXYZ()` a `renderXYZ()` budou volány a která šablona se načte. Jinak prostě platí, že view == action.

/--comment
Tím, že takové pohledy neexistují, nelze je ani přes URL vyvolat (například napsat URL, které by existující zboží zobrazilo v pohledu/šabloně nedostupného zboží).
\--
