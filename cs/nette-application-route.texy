Nette\Application\Route
*************************
.[perex]
Úkolem routy je nejen cestu naparsovat a vytvořit z ní interní požadavek, ale i přesný opak -- z interního požadavku vygenerovat cestu, která na něj odkazuje.

Třída *Route* implementující rozhraní [IRouter | api:Nette\Application\IRouter] je v případě správného použití snadným nástrojem pro tvorbu *user-friendly* URL adres. Že nejde o nic složitého se můžete přesvědčit sami níže.


Tvorba rout
-----------
Důležitým parametrem při tvorbě routy je maska cesty, nebo-li validační výraz. Validační výrazy jsou klasické regulární výrazy. Vlastně se dá říct, že pokud žádný validátor neuvedete, tak se použije `[^/]+`. Dalším parametrem je pole výchozích a povinných hodnot.

/--code php
$application = Environment::getApplication();
$router = $application->getRouter();

// nebo all-in-one row
$router = Environment::getApplication()->getRouter();

// vytvoření jednosměrné routy, která bude odchytávat
// všechny dotazy směrující na index.php
// a přesměrovávat na routu níže do cool-url tvaru
// automaticky zohledňuje SEO,
// takže se vám tyto stránky nezaindexují dvakrát
$router[] = new Route('index.php', array(
	'presenter' => 'Article',
	'view' => 'show',
), Route::ONE_WAY);

// deklarace obecné dvousměrné routy s cool-url tvarem
$router[] = new Route('<presenter>/<view>/<id>', array(
	'presenter' => 'Article',
	'view' => 'show',
	'id' => NULL,
));

// vytvoříme odkaz
$presenter->link('Article:'); // ekvivalentní s Article:show
\--

Routa s `index.php` určuje, že při požadavku na stránku `index.php` se otevře presenter `Article` a view `show`. Lze ji použít pro zpětnou kompatibilitu – pokud na web již existují odkazy ve tvaru `http://example.com/index.php`, je vhodné podchytit.

U zpětně kompatibilních rout se nastavuje příznak `Route::ONE_WAY` (jednosměrka), který zajistí, že routa může požadavek přijmout (stránka `index.php` funguje), ale **nevytváří URL**. Při přístupu na jednosměrné routy se request automaticky přesměruje na kompatibilní routu, pokud existuje taková. Tedy při generování URL pro presenter `Article` a view `show` se nevygeneruje `index.php`, ale použije se další routa.

.[tip]
Má-li být parametrem routy cesta filesystému, pak maskou `.*?` povolíme všechny znaky včetně lomítek.  Například: `new Route('/storage/<path .*?>', ...)`

Pokud jsou routy nainicializovány jako ty v příkladu výše (uvedení výchozích hodnot presenteru a view), nemusí se v metodách pro tvorbu odkazů uvádět celá maska routy. View není potřeba uvádět vůbec – výchozí hodnota je `default` zcela automaticky.

.[note]
V případě nenalezení routy se vyhodí výjimka.
 Pokud se žádná routa nenastaví, tak se o správné chování postará automaticky [SimpleRouter | Nette\Application\SimpleRouter].

Unitř aplikace se odkazuje tak, jako když jsou volány metody v OOP: `Presenter::view($arg1, $arg2)`. Konrétně třeba `Product:detail($id)`. Voláme metodu `detail` třídy `Product` a předáme jí parametr `$id`. Podrobně je filosofie routování popsána v [jiném článku | Routování].


Foo parametry
-------------

Foo parametry usnadňují definici rout. Narozdíl od klasických parametrů nemají název (místo něj se použije otazník), nepředávají se presenteru a slouží k tomu, aby bylo možné do masky přidat regulární výraz.

Příklad: jednosměrná routa akceptující `index.html`, `index.htm` a `index.php`.

/--code php
$router[] = new Route('index<? \.html?|\.php>', array(
        'presenter' => 'Homepage',
        'view' => 'default',
), Route::ONE_WAY);
\--

Pokud by uvedená routa byla obousměrná, generovala by cestu index, kterou však sama neumí akceptovat. Výraz by se proto musel rozšířit i o prázdnou hodnotu na `'index<? \.html?|\.php|>'`.

Nebo lze explicitně definovat řetězec, který bude při generování cesty použit (obdoba výchozí hodnoty u skutečných parametrů). Řetězec se vloží ihned za otazník:

/--code php
$router[] = new Route('feed<?.xml \.xml|>', array(
        'presenter' => 'Feed',
        'view' => 'rss',
));
\--

Tato routa akceptuje cesty `feed.xml` a `feed`, přičemž generuje `feed.xml`.


Používání rout/odkazů v šablonách
-------------------------
Rozlišujeme více možností vytvoření odkazu, proto **není jedno na jakém objektu metodu `link()` voláme**. Jelikož view může měnit pouze presenter, komponenty pracují vždy pod tímto prahem. Navíc se prohledávají odkazy v hierarchii směrem dolů k potomkům. Tudíž `$component->link()` vede na [signál | Nette\Application\Presenter#subrequest], `$presenter->link()` obvykle na view (nebo signál, je-li označen vykřičníkem). Pro úplnost, i komponenta může volat `$this->presenter->link('view')`.

V šabloně se odkazy velmi často vytvářejí (příklad s využitím filtru curlyBrackets):

/--code html
<a href="{$presenter->link('edit', 10)}">self::edit(10)</a>
<a href="{$presenter->link('Product:list')}">Product::list()</a>

<a href="{$control->link('Article:view')}">Zobrazit články</a>     // jedna z možností
<a href="{$presenter->link('Article:view')}">Zobrazit články</a>   // další z možností
<a href="{$component->link('Article:view')}">Zobrazit články</a>   // a do třetice

// jiná možnost: použít všechny možnosti filtru curly brackets

<a href="{link Article:view}">Zobrazit články</a>      // control link
<a href="{plink Article:view}">Zobrazit články</a>     // presenter link
<a href="{ajaxlink Article:view}">Zobrazit články</a>  // ajax link / subrequest
\--

Experimentálně lze využít i filtr netteLinks:
/--code html
<a href="nette:edit?id=10">self::edit(10)</a>
<a href="nette:Product:list">Product::list()</a>
\--

URL generuje v presenteru (a komponentě) funkce `$this->link('edit', 10)` – tedy stejně jako v šabloně. Lze vygenerovat URL sám na sebe `$this->backlink()`. K přesměrování slouží `$this->redirect(...)`, k přechodu na jiný presenter/view `$this->forward(...)`. Rozdíl je v tom, že `redirect` provede přesměrování na jinou stránku pomocí HTTP a `forward` jen přepošle zpracování jinam.


Odkaz na jiný presenter
-----------------------
Pro odkazování se do jiného než aktuálního presenteru se používá zápis ve tvaru:
 `$link->(destination [,arg [,arg ...]])` kde `destination` je:
- `'anotherView'` (odkaz na aktuální presenter a `anotherView`)
- `'AnotherPresenter:anotherView'` (odkaz na `AnotherPresenter` a `anotherView`)
- `'AnotherPresenter:'` (ozkaz na `AnotherPresenter` a výchozí view `'default'`)
- `'AnotherModule:Presenter:view'` (odkaz do jiného modulu)

Viz také: .[see]
- [Fully qualified view]


Dynamické přidávání rout
------------
Nyní si ukážeme, jak zaroutovat do naší aplikace nějaký existující modul.

Dejme tomu, že do website programované v Nette chceme přidat fórum. Stačí, aby fórum disponovalo instalační funkcí `createRoutes()`:
/--code php
class Forum
{
    function createRoutes($router, $prefix)
    {
        $router[] = new Route($prefix . 'index.php', array(
            'presenter' => 'Forum:Homepage',
            'view' => 'default',
        ));
        $router[] = new Route($prefix . 'admin.php', array(
            'presenter' => 'Forum:Admin',
            'view' => 'default',
        ));
        ...
    }
}
\--


"Zaroutování" fóra do existující aplikace je pak velmi jednoduché. `bootstrap.php`:
/--code php
$router = $application->getRouter();
// přidáme své routy
...
// přidáme modul forum
Forum::createRoutes($router, '//forum.example.com/');
\--


Multijazyčnost
--------------
Nette Framework nikomu nevnucuje konkrétní řešení. Otázkou mnohých složitějších systémů je multijazyčnost. Základem k jejímu vyřešení je dobrý návrh rout. Možností jak vyřešit tento požadavek je spostu a vše záleží jen na Vaší představivosti. Můžete se inspirovat na pár příkladech:
/--code php
// nejjednodušší způsob řešení
$router[] = new Route('/article/<id>', array(
    'presenter' => 'Article',
    'lang' => 'en',
));

$router[] = new Route('/clanek/<id>', array(
    'presenter' => 'Article',
    'lang' => 'cs',
));

// další z možností: název jazyka ve tvaru doménu 3. řádu
$router[] = new Route('//<lang {?cs|en}>.example.com/<id>/<view>', array( ... ), Route::ONE_WAY);
$router[] = new Route('//<lang [a-z]{2}>.example.com/<id>/<view>', array( ... ), Route::ONE_WAY);


// další možnost: povinné a volitelné parametry
// - module je zadán a není v masce => nepovinný
// - lang není zadán a podléhá masce => povinný
$router[] = new Route('<lang [a-z]{2}>/<id>/<view>', array(
     'module' => 'Front',
     'presenter' => 'Homepage',
     'view' => 'default',
     'id' => NULL // takto definovaný parametr je volitelný
));
// poté někde ve startup() zavoláme: $this->lang = $this->getParam('lang');
\--

Viz také: .[see]
- [Routování]
- [Fórum: Příklady routeru | http://forum.nette.org/cs/654-priklady-routeru]
- [Fórum: Routovací tipy a triky | http://forum.nette.org/cs/1001-routovaci-tipy-a-triky]
