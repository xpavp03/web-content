Vytvoření modelu
****************

.[caution]
Tato stránka je stále v procesu tvorby, informace od této hlášky dále nejsou relevantní. QuickStart by měl být dokončen do konce 8. 3. 2010. Pracujeme jak nejrychleji je to možné. Zatím si přečtěte "Seriál o Nette Frameworku na Zdrojáku":http://zdrojak.root.cz/serialy/zaciname-s-nette-framework/.

/--comment
Todo:
* Přidat odkazy do officiální dokumentace
* Přidat archiv s aplikací
\--

.[perex]
V předchozím díle jsme si ukázali, jak vytvořit šablonu, zatím jsme ji nenaplňovali daty - data sice máme, ale nemáme k nim žádný přístup - pojďme to napravit!

Co je to model?
=================
Model, jak již bylo řečeno, je písmenko "M" z M**V**P. U šablon jsme **data** zobrazovali, abychom je ale mohli zobrazit, je třeba je odněkud (typicky z databáze, nemusí to ale vždy platit) získat a předat je presenteru (který je upraví a předá šabloně) - právě za to zodpovídá model.

Co je to model v Nette Frameworku?
====================================
Narozdíl od šablon a presenterů, které mají svou naprosto exaktní formu, nám Nette při tvorbě modelů dává naprostou volnost. Obvykle se v modelech používá databázová vrstva - dibi, kterou jsme si do našeho projektu již přidali.

Začínáme!
=========
Abychom s daty mohli pracovat, je třeba se připojit k databázi. V Nette jsou typické dvě cesty - připojení se v bootstrapu, nebo v BaseModelu. My si ukážeme tu první.

Připojení se k databázi
===========
Otevřeme si soubor app/config.ini z našeho projektu, první co nás praští do očí je bezpečnostní varování - stejně jako při manipulaci s pilou je třeba dodržovat určité "bezpečnostní pokyny":http://nette.org/security-warning. Do souboru vyplníme údaje pro připojení k databázi, v našem případě by soubor config.ini vypadat zhruba takto:
/--code
;
; SECURITY WARNING: it is CRITICAL that this file & directory are NOT accessible directly via a web browser!
; http://nette.org/security-warning
;
[common]
; PHP configuration
php.date.timezone = "Europe/Prague"

; variables
variable.tempDir = %appDir%/temp
variable.logDir = %appDir%/log

; services
service.Nette-Security-IAuthenticator = Users

service.Nette-Loaders-RobotLoader.option.directory[] = %appDir%
service.Nette-Loaders-RobotLoader.option.directory[] = %libsDir%
service.Nette-Loaders-RobotLoader.run = TRUE

[production < common]
; common database connection
database.driver = mysql
database.database = todolist
database.charset = utf8
database.lazy = TRUE
database.host = localhost
database.username = produkcnilogin
database.password = produkcniheslo

[development < production]
; database options in development mode
database.profiler = TRUE
database.username = root
database.password = root
\--

Zde můžeme vidět další Nette výhodu - naprosto Vás odstíní od starostí na serveru - v config.ini si již **předvyplníte** přihlašovací údaje v produkčním režimu (tedy na ostrém serveru) a Nette si samo vybere, kterou z konfigurací použije. Již jsme "skoro připojeni", zbývá doplnit do souboru bootstrap.php následující řádek obstarávající samotné připojení k DB:
/--code php
dibi::connect(Environment::getConfig('database'));
\--
To je vše! Nyní jsme připojeni k DB a můžeme využívat výhod dibi v modelech.

Píšeme model
===========
V naší aplikaci vytvoříme dvě nové třídy (ve složce app/models). Proč dvě? Využijeme návrhového vzoru Active Record - jedna třída bude reprezentovat záznam z DB, zatímco druhá bude obstarávat vracení záznamů z DB ve formátu dané třídy. V našem případě vytvoříme třídy Todo a TodoManager, Todo bude reprezentovat záznam z DB (a půjde na ní volat např. metody save() či delete()), zatímco TodoManager zajistí, že vybraná data "připlují" k presenteru ve formátu buď třídy Todo, nebo jako pole objektů Todo.

Třídu Todo napíšeme zhruba takto:

/--code php
class Todo extends DibiRow // dibirow obstará korektní načtení dat
{
	public function delete()
	{
		return dibi::query("DELETE FROM [todolist] WHERE [id]=%i", $this->id);
	}

	public function save()
	{
		return dibi::query("UPDATE [todolist] SET", (array)$this, "WHERE [id]=%i", $this->id); // využijeme toho, že DibiRow dědí od ArrayObject
	}
}
\--
Třída TodoManager bude vypadat následovně:
/--code php
class TodoManager
{
	public function findAll($order = NULL, $where = NULL, $limit = NULL, $offset = NULL)
	{
		return dibi::query("SELECT *
				    FROM [todolist]
	      %if", isset($where), "WHERE %and", $where, "%end",
	     "%if", isset($order), "ORDER BY %by", $order, "%end",
	     "%if", isset($limit), "LIMIT %i %end", $limit,
	    "%if", isset($offset), "OFFSET %i %end", $order);
	}

	public function insert(Todo $todo)
	{
		return dibi::query("INSERT INTO [todolist]", (array)$todo);
	}
}
\--

V příští části návodu si ukážeme, jak data získaná z modelu načteme skrze presenter do šablony.


Co bychom si měli zapamatovat?
===========================
- Jak se připojit k databázi
