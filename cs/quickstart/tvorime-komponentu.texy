Tvoříme komponentu
*******************


Co je to komponenta? Pro pochopení toho, jakým způsobem se do sebe skládají jednotlivé objekty Nette a jaký je význam vykreslitelné komponenty, je ideální [slovníček pojmů|slovnik]. V našem ukázkovém případu se spokojíme s vysvětlením, že komponenta je část aplikace, kterou je možné opakovaně využívat. Sdružuje dohromady některé funkce, které spolu logicky souvisí a chceme je využívat na více místech aplikace.

V našem případě vytvoříme komponentu, která se bude starat hned o dvě věci zároveň - vypíše záznamy z aktuální tabulky (včetně zvoleného řazení) a umožní nám v případě většího množství záznamů zobrazovat záznamy po stránkách - stránkovat.

Ze [slovníčku|slovnik] už víte, že v Nette existují dva druhy komponent. **Komponenty** a **vykreslitelné komponenty**. V našem případě se budeme snažit vytvořit vykreslitelnou komponentu, jejíž výsledek bude viditelný prostým okem (alespoň v případě, že neuděláme chybu).

Pro náš pokus s vykreslitelnou komponentou si vytvoříme adresář `DataGrid/app/controls`, do kterého si budeme ukládat všechny soubory se zdrojovými kódy, které bude komponenta využívat.

Z čeho se tedy bude komponenta skládat? Na jedné straně musíme umět komponentě nějakým způsobem říci, co má udělat (jakou funkci od ní právě očekáváme). Druhým úkolem komponenty pak bude na základě přijatých dat vykreslit výsledek.

K tomu, abychom uměli komponentě říci, co po ní chceme, nám slouží *signály*. Pro hlubší pochopení pomůže prostudovat vysvětlení na [fóru | http://forum.nette.org/cs/803-ako-funguju-signaly] a popis [životního cyklu presenteru|nette-application-presenter#subrequest].

V našem případě budou signály dva:
- změna řazení
- přestránkování

Signály
-------

Každý signál je reprezentován veřejnou metodou s předponou handle. V našem malém příkladu tedy vytvoříme metody (handlery) `handlePage` a `handleOrder`. Tyto signály říkají objektu, co má udělat - informují o změně stavu.

Podívejme se na kód `handleOrder`:

/--php
	/**
	 * Changes column sorting order
	 */
	public function handleOrder($orderBy)
	{
		parse_str($this->order, $list);

		if (!isset($list[$orderBy])) {
			$list[$orderBy] = 'a';
		} elseif ($list[$orderBy] === 'd') {
			unset($list[$orderBy]);
		} else {
			$list[$orderBy] = 'd';
		}

		$this->order = http_build_query($list, '', '&');
	}
\--

Uvedený signál využívá vlastní proměnnou `$orderBy`, ovlivňující jeho chování. Na základě uložených informací o zvoleném řazení (v persistentní proměnné `$order`) změní řazení záznamů, které budou zobrazovány.

A co kód `handlePage`:

/--php
	/**
	 * Changes page number.
	 */
	public function handlePage($page)
	{
	}
\--

Díky uvedení proměnné `$page` získáme obsah této proměnné. Nic víc nepotřebujeme. Mohli bychom například upravit chování aplikaci v situaci, kdy se budeme snažit zobrazit stránku, která je mimo rozsah existujících stran. Ale nekomplikujme si prozatím život.

Vykreslení
----------

Díky signálům jsme schopni získat parametry, ovlivňující zobrazení záznamů. Co brání zobrazení záznamů? Absence odpovídajícího kódu. Vytvořme si tedy metody, které nám záznamy zobrazí. Ale nejprve nad tím popřemýšlíme.

I v tomto případě s výhodou využijeme šablon. A rozdělíme si zobrazení záznamů do dvou logických celků:
- zobrazení tabulky se záznamy
- zobrazení "navigace" stránkování

Důvod je prostý - znovupoužitelnost kódu. Představme si situaci, kdy bychom chtěli mít možnost zobrazit stránkování nad i pod tabulkou se záznamy. Proč ne - necháme pouze dvakrát vykreslit příslušnou část.

Nejprve tedy metoda pro naplnění šablony, vykreslující tabulku se záznamy:

/--php
	/**
	 * Renders table grid
	 */
	public function renderGrid()
	{
		$query = $this->db->select('*')
			->from($this->table)
			->offset($this->page * $this->rowsPerPage)
			->limit($this->rowsPerPage);

		parse_str($this->order, $list);
		$i = 1;
		foreach ($list as $field => $dir) {
			$query->orderBy($field, $dir === 'a' ? 'ASC' : 'DESC');
			$list[$field] = array($dir, $i++);
		}

		$rowset = $query->execute();

		$template = $this->createTemplate();
		$template->rows = $rowset->fetchAll();
		$template->columns = $rowset->getColumnNames();
		$template->order = $list;
		$template->setFile(dirname(__FILE__) . '/grid.phtml');
		$template->registerFilter(/*Nette\Templates\*/'CurlyBracketsFilter::invoke');
		$template->render();
	}
\--

V předchozím kódu se odkazujeme na šablonu pro zobrazení tabulky se záznamy `grid.phtml`. Všimněme si, jakým způsobem se volá potřebný signál i s příslušným parametrem:
/--code html

<table class="grid" border="1">
<tr>
	{foreach $columns as $column}
	<th><a href="{link order $column}"
	{if isset($order[$column])} class="{$order[$column][0] === 'a' ? 'asc' : 'desc'}"{/if}
	>{$column}{if count($order) > 1 && isset($order[$column])}&nbsp;<span>{$order[$column][1]}</span>{/if}</a></th>
	{/foreach}
</tr>

{foreach $rows as $num => $row}
<tr{!$num % 2 ? ' class="alt"' : ''}>

	{foreach $row as $value}
	<td>{=substr($value, 0, 100)}</td>
	{/foreach}

</tr>
{/foreach}
</table>
\--

Tabulka se záznamy už by mohla být zobrazena. Zbývá tedy navigace pro stránkování. Opět si připravíme metodu, která nám naplní šablonu příslušnými daty:

/--php
	/**
	 * Renders paginator
	 */
	public function renderPaginator()
	{
		$numOfRows = $this->db->select('count(*)')->from($this->table)->fetchSingle();
		$numOfPages = (int) ceil($numOfRows / $this->rowsPerPage);
		$this->page = max(0, min($this->page, $numOfPages - 1));

		if ($numOfPages < 2) return;

		$steps = range(max(0, $this->page - 3), min($numOfPages - 1, $this->page + 3));
		$steps = array_merge($steps, range(0, $numOfPages - 1, (int) ceil($numOfPages / 5)));
		$steps[] = $numOfPages - 1;
		sort($steps);
		$steps = array_unique($steps);

		$template = $this->createTemplate();
		$template->currentPage = $this->page;
		$template->numOfPages = $numOfPages;
		$template->steps = $steps;
		$template->setFile(dirname(__FILE__) . '/paginator.phtml');
		$template->registerFilter(/*Nette\Templates\*/'CurlyBracketsFilter::invoke');
		$template->render();
	}
\--

A nyní zbývá jen vytvořit šablonu pro zobrazení navigace se jménem `paginator.phtml`:

/--code html
<div class="paginator">
	{if $currentPage > 0}
	<a href="{link page, $currentPage - 1}">« Previous</a>
	{else}
	<span class="button">« Previous</span>
	{/if}

	{foreach $steps as $num}
	{if isset($lastNum) && $num - $lastNum > 1}<span>…</span>{/if}
	{if $num == $currentPage}
		<span class="current">{$num + 1}</span>
	{else}
		<a href="{link page, $num}">{$num + 1}</a>
	{/if}
	{? $lastNum = $num }
	{/foreach}

	{if $currentPage < $numOfPages - 1}
	<a href="{link page, $currentPage + 1}">Next »</a>
	{else}
	<span class="button">Next »</span>
	{/if}
</div>
\--

Naše práce je téměř u konce. Komponenta umí naplnit šablony správnými daty, umí šablony vykreslit. Teď je na řadě naši komponentu využít. Je potřeba změnit presenter, mající na starosti práci se záznamy konkrétní tabulky. Drobně upravíme výchozí metodu a nesmíme samozřejmě zapomenout na odkaz na soubor se zdrojovým kódem naší komponenty. Po úpravách vypadá `TablePresenter.php` takto:

/--php
<?php

require_once dirname(__FILE__) . '/BasePresenter.php';
require_once dirname(__FILE__) . '/../controls/DataGrid.php';

class TablePresenter extends BasePresenter
{
	public function presentDefault($table)
	{
		$dataGrid = new DataGrid($this, 'tc');
		$dataGrid->bindDataTable($this->db, $table);

		$this->template->dataGrid = $dataGrid;
		$this->template->table = $table;
	}
}
\--

Poslední úprava, která nás čeká, je zobrazení komponenty. Musíme tedy upravit i výchozí šablonu presenteru. Nově bude šablona `Table.default.phtml` vypadat takto:

/--code html
<h2>Table „{$table}“</h2>

<p><a href="{plink Default:}">Return to home</a></p>

{?$dataGrid->renderPaginator()}

{?$dataGrid->renderGrid()}
\--

Hurá - jsme na konci! Funkční aplikace s šablonou je na světě.

Aplikace si můžete opět [stáhnout | download:tutorial.datagrid.part4.zip]. .[download]
