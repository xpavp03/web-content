Získávání závislostí
********************

/--div .[perex]
Existuje několik možností, jakým do presenterů, komponent a služeb můžeme dostat (injektovat) jejich závislosti. V tomto článku probereme:

* obecné možnosti získávání závislostí, nejen těch z "DI Containeru":[dependency-injection] v Nette a
* konkrétní příklady a doporučení pro presentery, komponenty a služby.
\--


Jak získávat závislosti?
========================

Závislosti je možné do aplikačních tříd získávat čtyřmi hlavními způsoby:

* předávání konstruktorem,
* předávání setterem nebo nastavením vlastnosti,
* metodou `inject*` 
* anotací `@inject` u vlastnosti s typem přístupu `public`.

První dva způsoby platí obecně ve všech objektově orientovaných jazycích, zbylé jsou specifické pro Nette. Nyní si jednotlivé možnosti přiblížíme a poté přejdeme k jejich aplikaci v konkrétních případech.


Předávání konstruktorem
-----------------------

Závislosti, které se předávají v okamžiku vytváření objektu. Závislost je deklarována jako parametr konstruktoru a její typ je uveden jako Type Hint:

/--php
class MyService
{
	/** @var AnotherService */
	private $anotherService

	public __construct(AnotherService $service) {
		$this->anotherService = $service;
	}
}
\--

Třída `MyService` takto deklaruje, že při vytváření objektu jí musí být předána instance třídy `AnotherService`. Tato deklarace závislostí je vhodná pro povinné závislosti, které třída nezbytně potřebuje ke své funkci, neboť bez ní nepůjde instanci vytvořit.


Předávání setterem či nastavením vlastnosti
-------------------------------------------

Tyto závislosti jsou předávány až po vytvoření objektu. Nejprve uveďme příklad nastavení závislosti setterem. Typ požadované závislosti je uveden jako Type Hint:

/--php
class MyService
{
	/** @var AnotherService */
	private $anotherService
		
	public function setAnotherService(AnotherService $service)
	{
		$this->anotherService = $service;
	}
}
\--

Objektu je možné závislost předat až po jeho vytvoření. Tento způsob je vhodný pouze pro nepovinné vlastnosti, které nejsou pro funkci třídy nezbytné, neboť není garantováno, že objekt závislost skutečně dostane.

Podobně pak bude fungovat nastavení vlastnosti:

/--php
class MyService
{
	/** @var AnotherService */
	public $anotherService;
}
\--

Tento způsob je však nevhodný, neboť vlastnost musí být deklarována jako `public` a nemáme kontrolu nad tím, že předaná závislost bude skutečně daného typu. Přicházíme také o možnost reagovat na nově přiřazenou závislost vlastním kódem a porušujeme také princip zapouzdření.

Tímto způsobem se tedy nebudeme dále zabývat.

Předávání metodou `inject*`
---------------------------

Tento způsob je specifický pro DI Container v Nette. Jedná se o zvláštní případ setteru, metoda začíná prefixem `inject`. 

/--php
class MyService
{
	/** @var AnotherService */
	public $anotherService;
	
	public function injectAnotherService(AnotherService $service)
	{
		$this->anotherService = $service;
	}
}
\--

Metod `inject*` může třída obsahovat několik a každá může mít více parametrů. Každá metoda musí mít samozřejmě unikátní název.

Základní rozdíl od setteru je ten, že Nette je takto pojmenovanou metodu schopné najít a v některých případech zavolat automaticky.

Anotace `@inject`
-----------------

Další způsob specifický pro DI Container v Nette. Jedná se o zvláštní případ závislostí předávaných pomocí veřejné vlastnosti, tentokrát je však vlastnost označena anotací `@inject` v dokumentačním komentáři. Typ předávané závislosti je uveden v dokumentačním komentáři:

/--php
class MyService
{
	/** @inject @var \App\AnotherService */
	public $anotherService;
}
\--

Nette opět může takto anotovanou vlastnost najít a automaticky vlastnost injektovat. Jako typ třídy však musí být uveden její plně kvalifikovaný název, tj. včetně celé cesty v namespace. Nelze využít názvů tříd importovaných pomocí direktiv `use`.

Tento způsob má podobné nedostatky, jako předávání závislosti do veřejné proměnné - opět nelze vynutit typ předávané třídy a musíme se spolehnout na to, že bude předána instance správné třídy.

V některých případech však může jít o vhodnou variantu, neboť nekomplikuje kód a vyžaduje jen minimum psaní navíc.

Jaký způsob zvolit?
===================

Volba správného způsobu závisí na funkci třídy, kterou vytváříme. Volba správného způsobu se tedy bude lišit u presenterů, komponent a služeb.

Pro všechny způsoby je však společné to, že [automatické dosazování závislostí (auto-wiring) | configuring#auto-wiring] funguje pouze u objektů, které Nette vytváří automaticky prostřednictvím DI Containeru nebo továren. Pokud objekt vytváříme voláním `new` ve vlastním kódu, musíme závislosti vždy předat sami.

Nyní se podíváme na jednotlivé příklady a uvedeme preferovaný způsob předávání závislostí.

Presentery
----------

Presentery vytváří Nette Framework automaticky prostřednictvím příslušné továrny, která i zajišťuje předání příslušných závislostí. Automaticky jsou předány:

1) závislosti uvedené v konstruktoru,
2) závislosti voláním metod `inject*`,
3) závislosti předané do vlastností s anotací `@inject`.

Následující presenter ilustruje všechny tři způsoby předávání:

/--php
class MyPresenter extends Nette\Application\UI\Presenter
{	
	// 1) Předání konstruktorem:
	private $service1;
	
	public function __construct(Service1 $service)
	{
		$this->service1 = $service;
	}
	
	// 2) Předání metodou inject*:
	private $service2;
	
	public function injectService2(Service2 $service)
	{
		$this->service2 = $service;
	}
	
	// 3) Předání do vlastnosti s anotací @inject:
	/** @inject @var \App\Service3 */
	public $service3;
}
\--

Preferovaný způsob předávání závislostí je pomocí anotace `@inject`, neboť nekomplikuje kód a Nette se o předání správné závislosti stará automaticky.

Pokud potřebujete přesně definovat kontrakt presenteru (může být vhodné například pro testování), použijte metody `@inject`.

Předávání pomocí konstruktoru je spíše nedoporučované, protože při dědění presenterů je nutné získávat závislosti i všech rodičovských presenterů a to komplikuje signaturu konstruktoru.

Komponenty
----------

Komponenty jsou typicky vytvářeny přímo v kódu presenteru, nebo prostřednictvím továren, které jsou specifické pro danou aplikaci. V těchto případech Nette nemůže závislosti automaticky předat a není možné použít metody `inject*`, ani anotaci `@inject`.

Uvažujme následující komponentu:

/--php
class MyControl extends Nette\Application\UI\Control
{
	// 1) Předání konstruktorem:
	private $service1;
	
	public function __construct(Service1 $service)
	{
		parent::__construct();
		$this->service1 = $service;
	}
	
	// 2) Předání setterem:
	private $service2;
	
	public function setService2(Service2 $service)
	{
		$this->service2 = $service;
	}
}
\--

Její použití v presenteru by vypadalo následovně:

/--php
class MyPresenter extends Nette\Application\UI\Presenter
{
	/** @inject @var \App\Service1 */
	private $service1;
	/** @inject @var \App\Service2 */
	private $service2;
	
	protected function createCompoonentMyControl()
	{
		$control = new MyControl($this->service1);
		$control->setService2($this->service2);
		return $control;
	}
}
\--

Protože závislosti nejsou z DI Containeru předávány automaticky, musíme je získat ve třídě, která danou komponentu vytváří. V našem případě jde o presenter. Pokud bychom komponentu vytvářeli v jiné komponentě, musíme její závislosti přidat k závislostem rodičovské komponenty:

/--php
class MySecondControl extends Nette\Application\UI\Control
{
	// Závislost pro MySecondControl:
	private $service3;
	// Závislosti pro vnořenou MyControl:
	private $service1;
	private $service2;
	
	public function __construct(Service1 $service1, Service2 $service2,
	                            Service3 $service3)
	{
		public::__construct();
		// přiřazení do členských proměnných $service1, $service2, $service3
	}
	
	protected function createCompoonentMyControl()
	{
		$control = new MyControl($this->service1);
		$control->setService2($this->service2);
		return $control;
	}
}
\--

Protože třídy komponent typicky vytváříme ručně, je preferovaný způsob předávání závislostí závislý na tom, zda je závislost povinná nebo není. V případě povinných závislostí použijeme konstruktor, v případě nepovinných setter.

.[caution]
Pozor, v případě předávání do konstruktoru nesmíme zapomenout na volání konstruktoru rodiče: `parent::__construct()`!

Služby
------

Služby jsou registrovány v DI Containeru a závislosti jsou tedy předávány automaticky. Pokud neuvedeme dodatečnou konfiguraci, budou předány pouze závislosti pomocí konstruktoru:

/--code neon
services:
	service1: App\Service1
\--

Takto definované službě budou při vytváření automaticky předány všechny závislosti uvedené v konstruktoru:

/--php
class Service1
{
	private $anotherService;
	
	public function __construct(AnotherService $service)
	{
		$this->anotherService = $service;
	}
}
\--

Předávání konstruktorem je preferovaný způsob pro služby.

Pokud chceme předávat závislosti pomocí setteru, můžeme definici služby rozšířit o sekci `setup`:

/--code neon
services:
	service2:
		class: App\Service2
		setup:
			- setAnotherService
\--

Třída služby:

/--php
class Service2
{
	private $anotherService;
	
	public function setAnotherService(AnotherService $service)
	{
		$this->anotherService = $service;
	}
}
\--

Uvedením konfigurační direktivy `inject: yes` pak můžeme zapnout i automatické volání metod `inject*` a předávání závislostí do vlastností označených anotací `@inject`:

/--code neon
services:
	service3:
		class: App\Service3
		inject: yes
\--

Závislost `Service1` bude předána voláním metody `inject*`, závislost `Service2` bude přiřazena do vlastnosti `$service2`:

/--php
class Service3
{
	// 1) Metoda inject*:
	private $service1;
	
	public function injectService1(Service1 $service)
	{
		$this->service1 = $service1;
	}
	
	// 2) Přiřazení do vlastnosti s anotací @inject:
	/** @inject @var \App\Service2 */
	public $service2;
}
\--
